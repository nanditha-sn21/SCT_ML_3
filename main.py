# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AlboCbZ_Jl8BLX92v-kdp1VC_BgcflNn
"""

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import classification_report, accuracy_score
import zipfile

# Assuming the uploaded file is 'dods vs cats.zip'
zip_file_path = 'cat.zip'
extracted_dir = 'cat' # Directory to extract the files to

# Unzip the file
print(f"Extracting {zip_file_path}...")
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extracted_dir)

# Set your extracted train folder path here
DATA_DIR = os.path.join(extracted_dir, 'dogs vs cats') # Assuming the extracted folder is also named 'dods vs cats'

# Parameters
IMG_SIZE = 64
NUM_IMAGES_PER_CLASS = 250

# Load Images
data = []
labels = []

print("Loading images...")
# Check if the data directory exists before proceeding
if not os.path.exists(DATA_DIR):
    print(f"Error: Data directory '{DATA_DIR}' not found after extraction.")
else:
    for img_name in os.listdir(DATA_DIR):
        if img_name.startswith('cat') and len([l for l in labels if l == 0]) < NUM_IMAGES_PER_CLASS:
            img_path = os.path.join(DATA_DIR, img_name)
            img = cv2.imread(img_path)
            if img is not None: # Check if image was loaded successfully
                img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
                data.append(img)
                labels.append(0)  # 0 = cat
        elif img_name.startswith('dog') and len([l for l in labels if l == 1]) < NUM_IMAGES_PER_CLASS:
            img_path = os.path.join(DATA_DIR, img_name)
            img = cv2.imread(img_path)
            if img is not None: # Check if image was loaded successfully
                img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
                data.append(img)
                labels.append(1)  # 1 = dog
        if len(labels) >= 2 * NUM_IMAGES_PER_CLASS:
            break

    # Preprocess
    if data: # Check if data is not empty
        data = np.array(data)
        data = data / 255.0  # normalize
        data = data.reshape(len(data), -1)
        labels = np.array(labels)

        # Split
        X_train, X_test, y_train, y_test = train_test_split(data, labels, test_size=0.2, random_state=42)

        # Train SVM
        print("Training SVM...")
        model = SVC(kernel='linear')
        model.fit(X_train, y_train)

        # Evaluate
        y_pred = model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)

        print("\nAccuracy:", acc)
        print("\nClassification Report:\n", classification_report(y_test, y_pred))

        # Optional: Show a few test predictions
        for i in range(min(5, len(X_test))): # Ensure we don't go out of bounds
            img = X_test[i].reshape(IMG_SIZE, IMG_SIZE, 3)
            label = y_pred[i]
            plt.imshow(img)
            plt.title("Predicted: " + ("Dog" if label == 1 else "Cat"))
            plt.axis('off')
            plt.show()
    else:
        print("No images were loaded. Please check the zip file content and the DATA_DIR path.")

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns

# Constants
IMG_SIZE = 64
BASE_PATH = 'dods vs cats/dods vs cats/training'  # Use the corrected extracted directory path

def load_images_from_folder(folder, label):
    images = []
    labels = []
    # Check if the folder exists
    if not os.path.exists(folder):
        print(f"Warning: Folder not found: {folder}")
        return images, labels # Return empty lists if folder not found

    for filename in os.listdir(folder):
        img_path = os.path.join(folder, filename)
        # Check if it's a file before trying to read
        if os.path.isfile(img_path):
            img = cv2.imread(img_path)
            if img is not None:
                img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
                images.append(img)
                labels.append(label)
    return images, labels

# Load images
train_cat_imgs, train_cat_labels = load_images_from_folder(os.path.join(BASE_PATH, 'cats'), 0)
train_dog_imgs, train_dog_labels = load_images_from_folder(os.path.join(BASE_PATH, 'dogs'), 1)
test_cat_imgs, test_cat_labels = load_images_from_folder(os.path.join(BASE_PATH, 'cats'), 0) # Assuming test data is in the same structure
test_dog_imgs, test_dog_labels = load_images_from_folder(os.path.join(BASE_PATH, 'dogs'), 1) # Assuming test data is in the same structure


# Combine
X_train = np.array(train_cat_imgs + train_dog_imgs) / 255.0
y_train = np.array(train_cat_labels + train_dog_labels)
X_test = np.array(test_cat_imgs + test_dog_imgs) / 255.0
y_test = np.array(test_cat_labels + test_dog_labels)

# Flatten for SVM
X_train_flat = X_train.reshape(len(X_train), -1)
X_test_flat = X_test.reshape(len(X_test), -1)

# Train SVM
print("Training SVM...")
model = SVC(kernel='linear')
model.fit(X_train_flat, y_train)

# Predict
y_pred = model.predict(X_test_flat)

# Accuracy
acc = accuracy_score(y_test, y_pred)
print(f"\n‚úÖ Accuracy: {acc * 100:.2f}%")
print("\n‚úÖ Classification Report:\n", classification_report(y_test, y_pred))

# üîç Confusion Matrix Plot
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(5,4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Cat', 'Dog'], yticklabels=['Cat', 'Dog'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

# üìä Bar Graph for Accuracy
plt.figure(figsize=(5,4))
plt.bar(['Accuracy'], [acc * 100], color='green')
plt.ylim(0, 100)
plt.ylabel("Accuracy %")
plt.title("SVM Accuracy on Dogs vs Cats")
plt.grid(axis='y')
plt.show()

# üñºÔ∏è Visualize 5 predictions
for i in range(min(5, len(X_test))):
    img = X_test[i]
    label = y_pred[i]
    true = y_test[i]
    plt.imshow(img)
    plt.title(f"True: {'Dog' if true else 'Cat'} | Pred: {'Dog' if label else 'Cat'}")
    plt.axis('off')
    plt.show()

import os

extracted_dir = 'dods vs cats' # Assuming this is still the extracted directory
print(os.listdir(extracted_dir))

import os

extracted_nested_dir = 'dods vs cats/dods vs cats' # Assuming this is the nested extracted directory
if os.path.exists(extracted_nested_dir):
    print(os.listdir(extracted_nested_dir))
else:
    print(f"Directory not found: {extracted_nested_dir}")